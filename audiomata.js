// Generated by CoffeeScript 1.10.0
(function() {
  var OSCSet, Rat, START, addRules, context, createNode, delRules, draw, gcd, oscSetProto, oscs, ratProto, reduce, restarter, setup, state, step;

  context = new (AudioContext || webkitAudioContext)();

  gcd = function(a, b) {
    if (b === 0) {
      return a;
    } else {
      return gcd(b, a % b);
    }
  };

  ratProto = {
    norm: function() {
      var g;
      if (this.b < 0) {
        this.a = -this.a;
        this.b = -this.b;
      }
      g = gcd(this.a, this.b);
      this.a /= g;
      this.b /= g;
      return this;
    },
    add: function(a, b) {
      this.a = (a * this.b) + (this.a * b);
      this.b = b * this.b;
      return this.norm();
    },
    sub: function(a, b) {
      return this.add(-a, b);
    },
    mult: function(a, b) {
      this.a *= a;
      this.b *= b;
      return this.norm();
    },
    div: function(a, b) {
      return this.mult(b, a);
    }
  };

  Rat = function(a, b) {
    var o;
    o = Object.create(ratProto);
    o.a = a;
    o.b = b;
    return o;
  };

  START = 440;

  createNode = function(a, b) {
    var gain, osc;
    osc = context.createOscillator();
    osc.start(context.currentTime + 0.01 + Math.random() * 0.01);
    osc.frequency.value = 440 * a / b;
    gain = context.createGain();
    gain.connect(context.destination);
    gain.gain.value = 1 / 8;
    osc.connect(gain);
    return {
      osc: osc,
      gain: gain
    };
  };

  reduce = function(a, b) {
    var g;
    if (b < 0) {
      a = -a;
      b = -b;
    }
    g = gcd(a, b);
    return [a / g, b / g];
  };

  oscSetProto = {
    add: function(a, b) {
      var o, ref;
      ref = reduce(a, b), a = ref[0], b = ref[1];
      if (this.obj[a + ":" + b]) {
        return this.get(a, b);
      }
      o = Rat(a, b);
      o.node = createNode(a, b);
      this.obj[a + ":" + b] = o;
      return o;
    },
    remove: function(osc) {
      osc.node.gain.gain.value = 0;
      osc.node.osc.stop(context.currentTime + 0.01 + Math.random() * 0.01);
      return delete this.obj[osc.a + ":" + osc.b];
    },
    get: function(a, b) {
      var ref;
      ref = reduce(a, b), a = ref[0], b = ref[1];
      return this.obj[a + ":" + b];
    },
    each: function(f) {
      var k, ref, results, v;
      ref = this.obj;
      results = [];
      for (k in ref) {
        v = ref[k];
        results.push(f(v));
      }
      return results;
    },
    sorted: function() {
      var k, sorted, v;
      sorted = (function() {
        var ref, results;
        ref = this.obj;
        results = [];
        for (k in ref) {
          v = ref[k];
          results.push(v);
        }
        return results;
      }).call(this);
      sorted.sort(function(o1, o2) {
        return o1.a / o1.b - o2.a / o2.b;
      });
      return sorted;
    },
    nearest: function(osc) {
      var i, next, nextDist, prev, prevDist, sorted;
      sorted = this.sorted();
      i = sorted.indexOf(osc);
      prev = sorted[i - 1];
      next = sorted[i + 1];
      if (!prev && !next) {
        null;
      }
      prevDist = Math.abs((prev != null ? prev.a : void 0) / (prev != null ? prev.b : void 0) - osc.a / osc.b);
      nextDist = Math.abs((next != null ? next.a : void 0) / (next != null ? next.b : void 0) - osc.a / osc.b);
      if (prevDist > nextDist) {
        return prev;
      } else {
        return next;
      }
    },
    count: function() {
      return Object.keys(this.obj).length;
    }
  };

  OSCSet = function() {
    var o;
    o = Object.create(oscSetProto);
    o.obj = {};
    return o;
  };

  oscs = OSCSet();

  addRules = [];

  delRules = [];

  delRules.push(function(osc) {
    if (osc.a > 16 || osc.b > 16) {
      return oscs.remove(osc);
    }
  });

  delRules.push(function(osc) {
    if (osc.a / osc.b >= 3 || osc.b / osc.a >= 6) {
      return oscs.remove(osc);
    }
  });

  delRules.push(function(osc) {
    var nearest, rat;
    if (!(nearest = oscs.nearest(osc))) {
      return;
    }
    rat = Rat(osc.a * nearest.b, osc.b * nearest.a).norm();
    if (rat.a > 8 || rat.b > 4) {
      return oscs.remove(osc);
    }
  });

  addRules.push(function(osc) {
    if (osc.b > 1) {
      oscs.add(osc.a + 1, osc.b - 1);
    }
    oscs.add(osc.a + 1, osc.b + 2);
    oscs.add(osc.a * 1, osc.b * 3);
    return oscs.add(osc.a * 3, osc.b * 2);
  });

  state = document.getElementById('state');

  draw = function() {
    return state.innerHTML = (oscs.sorted().map(function(osc) {
      return osc.a + "/" + osc.b;
    })).join(", ");
  };

  restarter = null;

  step = function() {
    var sorted;
    oscs.each(function(osc) {
      var j, len, results, rule;
      results = [];
      for (j = 0, len = addRules.length; j < len; j++) {
        rule = addRules[j];
        results.push(rule(osc));
      }
      return results;
    });
    oscs.each(function(osc) {
      var j, len, results, rule;
      results = [];
      for (j = 0, len = delRules.length; j < len; j++) {
        rule = delRules[j];
        results.push(rule(osc));
      }
      return results;
    });
    sorted = oscs.sorted();
    if (sorted.length === 0 && !restarter) {
      restarter = setTimeout(setup, 1000);
    }
    return draw();
  };

  setup = function() {
    restarter = null;
    while (Math.random() > 1 / 8) {
      oscs.add(Math.round(Math.random() * 3 + 1), Math.round(Math.random() * 7 + 1));
    }
    return draw();
  };

  setup();

  setInterval(step, 200);

}).call(this);
